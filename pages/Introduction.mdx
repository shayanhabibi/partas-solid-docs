import { PartasSolidLink, OxpeckerSolidLink, FableLink } from "../output/links/Index.fs.jsx"

# Introduction

<PartasSolidLink>Partas.Solid</PartasSolidLink> is a plugin for <FableLink>Fable</FableLink>, a F# to JS
transpiler.

If you're not aware of <FableLink>Fable</FableLink>, and/or are new to F#, then I suggest you visit their website first
to see what it's all about! 

An opinionated fork of Lanayx's <OxpeckerSolidLink>Oxpecker.Solid</OxpeckerSolidLink>, the plugin aggressively transforms
the Fable AST to produce Solid-js compatible **JSX**. This allows you to have a front end with the performance of Solid-js,
with the F# language and compiler to prop up your development experience.

# Why Partas.Solid

<PartasSolidLink>Partas.Solid</PartasSolidLink> differs from other front end plugins in F# in its overarching goal:

> To define a DSL that allows building HTML/JSX trees for native, imported, **and** user defined components

## What this means

Before I discuss any further, let me just show you an example of what the intentions of this framework are:

### Building Component Functions

```fsharp title="Oxpecker.Solid & Partas.Solid" caption="Stock standard things (besides the DSL maybe being new to some people)"
[<SolidComponent>]
let MyComponent (myThesis: string) =
    div(class' = "flex justify-center") {
        "Hello World!"
        button(onClick = fun _ -> console.log("Hello World!")) { "Click me!" }
        myThesis
    }

[<SolidComponent>]
let Usage () = 
    div() {         
        MyComponent "Something about my thesis"
    }
```


```fsharp title="Feliz DSL" caption="Also stock standard, but in my opinion this is more verbose"
[<ReactComponent>]
let MyComponent (myThesis: string) =
    Html.div [
        prop.className "flex justify-center"
        prop.children [
            Html.text "Hello World!"
            Html.button [
                prop.onClick (fun _ -> console.log("Hello World!"))
                prop.text "Click me!"
            Html.text myThesis
            ]
        ]
    ]

[<ReactComponent>]
let Usage () =
    Html.div [
        MyComponent "Something about my thesis"
    ]
```

---

### Building DSL Components

```fsharp title="Making a component in Partas.Solid"
[<Erase>]
type MyComponent() =
    interface RegularNode // <-- specifies it can take children. inherits dom attributes like class'
    [<Erase>]
    member val myThesis: string = jsNative with get,set
    [<SolidTypeComponent>]
    member props.__ =
        div(class' = "flex justify-center") {
            "Hello World!"
            button(onClick=fun _ -> console.log("Hello World!")
            props.myThesis
        }

[<SolidComponent>]
let Usage () =
    div() {
        MyComponent(myThesis = "Something about my thesis")
    }
```

Looks the same right? But we can also do this:

```fsharp title="Making a component in Partas.Solid"
[<Erase>]
type MyComponent() =
    interface RegularNode // <-- specifies it can take children. inherits dom attributes like class'
    [<SolidTypeComponent>]
    member props.__ =
        div(class' = "flex justify-center") {
            "Hello World!"
            button(onClick=fun _ -> console.log("Hello World!")
            props.children // <-- children component property
        }

[<SolidComponent>]
let Usage () =
    div() {
        MyComponent() { // <-- computation expression for children
            "Something about my thesis"
        }
    }
```

It's been a hot minute since I've tried to write in Feliz, but I think it should go something like...

```fsharp title="Attempting in Feliz" caption="I gave up."
let private reactElement el props: ReactElement = import "createElement" "react"
let private createElement el props: ReactElement = reactElement el (!!props |> createObj)
let private createElementWithChildren el children: ReactElement = Feliz.Interop.reactElementWithChildren !!el children

type MyComponent =
    static member defaultProperties =
        // ... I shudder to think how much further this would have to go


type Html with
    static member inline MyComponent (props: IMyComponentProp list) = createElement ReactElement props
    static member inline MyComponent (children: ReactElement list) = createElementWithChildren ReactElement children
    static member inline MyComponent () = createElement ReactElement unbox<IMyComponentProp list>([])
```

Of course you could just use functions the whole way for Feliz. But my component can easily have classes applied right off the bat without having to modify/create a new binding with a different name (or using static members and parameters which would result in usage that is wildly different from the rest of the DSL).

The above is a trivial example, but you get the idea. You can compose flexible components into a library which are compiled and usable just like any JSX component library out there. You can then compose these into functions for that F# flavor we all love.

The point is YOU have more flexibility in composition.

### Compiled Output

By the way, does this look familiar?

```js title="Feliz/Fable compiled output" caption="(Recent efforts to make a Feliz version that uses the newer JSX helpers provided by Fable is underway which would make clean compiled code)"
function AppSideBar() {
    let el, el_2, el_4, el_6, children_1_4, children_1_2, children_1_1, children_1, children_1_3;
    const items = ofArray([{
        icon: (el = House, createElement(el, {})),
        title: "Home",
        url: "#",
    }, {
        icon: (el_2 = Inbox, createElement(el_2, {})),
        title: "Inbox",
        url: "#",
    }, {
        icon: (el_4 = Search, createElement(el_4, {})),
        title: "Calendar",
        url: "#",
    }, {
        icon: (el_6 = Settings, createElement(el_6, {})),
        title: "Settings",
        url: "#",
    }]);
    return createElement(Sidebar_1, {
        collapsible: "icon",
        children: (children_1_4 = ofArray([(children_1_2 = ofArray([createElement(SidebarGroupLabel_1, {
            children: "Application",
        }), (children_1_1 = singleton((children_1 = toList(delay(() => map((item) => {
            let elems_1, elems;
            return createElement(SidebarMenuItem_1, createObj(ofArray([["key", item.title], (elems_1 = [createElement(SidebarMenuButton_1, {
                asChild: true,
                tooltip: item.title,
                children: createElement("a", createObj(ofArray([["href", item.url], (elems = [item.icon, createElement("span", {
                    children: [item.title],
                })], ["children", reactApi.Children.toArray(Array.from(elems))])]))),
            })], ["children", reactApi_1.Children.toArray(Array.from(elems_1))])])));
        }, items))), createElement(SidebarMenu_1, {
            children: reactApi.Children.toArray(Array.from(children_1)),
        }))), createElement(SidebarGroupContent_1, {
            children: reactApi.Children.toArray(Array.from(children_1_1)),
        }))]), createElement(SidebarGroup_1, {
            children: reactApi.Children.toArray(Array.from(children_1_2)),
        })), (children_1_3 = singleton(defaultOf()), createElement(SidebarRail, {
            children: reactApi.Children.toArray(Array.from(children_1_3)),
        }))]), createElement(SidebarContent_1, {
            children: reactApi.Children.toArray(Array.from(children_1_4)),
        })),
    });
}
```

Here's what Partas.Solid produces when compiling my Sidebar code:

```jsx title="Partas.Solid Compiled output"
export function NavSidebarContent(props) {
    const [PARTAS_LOCAL, PARTAS_OTHERS] = splitProps(props, []);
    const ctx = SidebarModule_Context_useSidebar();
    return <For each={Data_Navigation_data}>
        {(group, index) => <SidebarGroup>
            <SidebarGroupLabel>
                {group.Title}
            </SidebarGroupLabel>
            <SidebarGroupContent>
                <SidebarMenu>
                    <For each={group.Items}>
                        {(item, itemIndex) => <SidebarMenuItem>
                            <SidebarMenuButton tooltip={item.Title}
                                class="group/mbutton disabled:cursor-default"
                                onClick={(_arg) => {
                                    if (Data_Window_isMobile() && ctx.openMobile()) {
                                        ctx.setOpenMobile(false);
                                    }
                                }}
                                as={(PARTAS_POLYPROPS) => <A {...PARTAS_POLYPROPS} on:n$={false}
                                    href={item.Path} />}>
                                {(item.Icon != null) ? <item.Icon /> : <Separator orientation="vertical"
                                    class="group-hover/mbutton:bg-black/20 in-aria-[current=page]:bg-black transition-colors group-hover/mbutton:in-aria-[current=page]:bg-black" />}
                                <span>
                                    {item.Title}
                                </span>
                            </SidebarMenuButton>
                        </SidebarMenuItem>}
                    </For>
                </SidebarMenu>
            </SidebarGroupContent>
        </SidebarGroup>}
    </For>;
}
```

I know which I would prefer to debug if I was suspicious the transpiled code was at fault for a bug, and not my business logic.

<div class="text-sm">
    _It's important to clarify here that the above example is not an admonishment of Feliz, its authors/contributors, nor users; it is simply
    a demonstration of what Partas.Solid has to offer._
</div>

---

Many front-end frameworks define a DSL that allows you to build a tree of native elements such as **Feliz**

But it is not possible to then use components in the same DSL. Your components are built into functions or static members. Static members would be the closest you could get to the flexibility of having optional properties/attributes.

You can interop with JS libraries, but the process can be laborious since you have to use various interop functions like mkProperty or createElement.

### Oxpecker Style - Computation Expressions

```fsharp title="Oxpecker DSL"
[<SolidComponent>]
let MyComponent () =
    div(class' = "flex justify-center") {
        button(class' = "bg-primary text-primary") {
            "Button"
        }
    }
```

<OxpeckerSolidLink>Oxpecker</OxpeckerSolidLink> provides a DSL that has several advantages in my view:

1. An error does not propagate into the whole list declaration resulting in brackets of red
2. Distinguishing between children and properties is more intuitive
3. Resembles JSX more closely
4. Makes interop less verbose
5. Subjectively less verbose

But it does come with its own costs associated with:
1. Constructor parameters suggestion/completion for extension setters is lacking (specifically in Rider, this is a known issue that hopefully is corrected in the future)
2. Computation Expressions can potentially burden analysers and slow down compilation in monoliths (but this is yet to be measured)

#### Interop with Oxpecker style

You can define new tags to interop with libraries:

```fsharp
namespace Partas.Solid.SomeLibrary
open Partas.Solid
open Fable.Core
[<Import("SomeComponent", "SomeLibrary")>]
type SomeComponent() =
    interface RegularNode
    [<Erase>] member val someAttribute: string = JS.undefined with get,set
```

Unfortunately, Oxpecker.Solid does not provide the functionality to fulfill the overarching goal above, as you cannot have **user-defined** components that are usable in the same DSL.

This is because Oxpecker.Solid has a divergent opinionated goal, which is to provide a clean, performant, and minimally intrusive plugin transformation to interop with Solid-js.

### Partas.Solid

```fsharp title="Partas expanded Oxpecker DSL"
type CenteredButton() =
    inherit button()
    [<SolidTypeComponent>]
    member props.constructor =
        div(class' = "flex justify-center") { button().spread props }
        
// ...

[<SolidComponent>]
let MyComponent () =
    CenteredButton(class' = "bg-primary text-primary") { "Button" }
```

While this fork moves towards its own opinionated goal, most (if not all) functionality of Oxpecker.Solid is adopted by Partas.Solid.

The larger breadth that Partas.Solid takes leads to more laborious and cumbersome requirements and development of the plugin API surface. But the end result is a more expansive and flexible developer experience.

## Why choose Partas.Solid?

Besides Solid-js being the most performant front end framework?

My goal is to make the most expressive and easy to use framework to produce your front end.

I am actively and extensively developing the plugin to be compatible with a wide variety of libraries, with usage being as native as possible.

You can rest assured that I will support you in your development process to the best of my ability.
